#!/usr/bin/env python
# -*- coding: utf-8 -*-# 
# @(#)run-on-all-images
# 
# 
# Copyright (C) 2014, GC3, University of Zurich. All rights reserved.
# 
# 
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
"""
This script will run an instance for each public glance image, and then will execute a command.

Created to test if all the instances have a specific command.
"""
__docformat__ = 'reStructuredText'
__author__ = 'Antonio Messina <antonio.s.messina@gmail.com>'

from glanceclient import client as glance_client
from keystoneclient import client as keystone_client
from novaclient import client as nova_client
import argparse
import novaclient.exceptions as nova_ex
import operator
import os
import paramiko
import socket
import sys
import time


DEFAULT_COMMAND="which fsfreeze"
WAIT=2
TIMEOUT=5

class EnvDefault(argparse.Action):
    # This is took from
    # http://stackoverflow.com/questions/10551117/setting-options-from-environment-variables-when-using-argparse
    def __init__(self, envvar, required=True, default=None, **kwargs):
        if not default and envvar:
            if envvar in os.environ:
                default = os.environ[envvar]
        if required and default:
            required = False
        super(EnvDefault, self).__init__(default=default, required=required, 
                                         **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, values)

class IgnorePolicy(paramiko.MissingHostKeyPolicy):
    def missing_host_key(self, client, hostname, key):
        pass


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--key-name', required=1, help='Keypair name.')
    parser.add_argument('--os-username', action=EnvDefault, envvar="OS_USERNAME",
                        help='OpenStack administrator username. If not supplied, the value of the '
                        '"OS_USERNAME" environment variable is used.')
    parser.add_argument('--os-password', action=EnvDefault, envvar="OS_PASSWORD",
                        help='OpenStack administrator password. If not supplied, the value of the '
                        '"OS_PASSWORD" environment variable is used.')
    parser.add_argument('--os-tenant-name', action=EnvDefault, envvar="OS_TENANT_NAME",
                        help='OpenStack administrator tenant name. If not supplied, the value of the '
                        '"OS_TENANT_NAME" environment variable is used.')
    parser.add_argument('--os-auth-url', action=EnvDefault, envvar="OS_AUTH_URL",
                        help='OpenStack auth url endpoint. If not supplied, the value of the '
                        '"OS_AUTH_URL" environment variable is used.')

    parser.add_argument('--flavor', default='m1.tiny', help='Flavor.')
    parser.add_argument('--public-images', action="store_true", default=False, help='Only use public images. Ignored if --images is used')
    parser.add_argument('-u', '--ssh-username', default='root', help='Username to use to connect to the VM')
    parser.add_argument('-v', '--verbose', action="count")

    parser.add_argument('--images', nargs='*', help='Image IDs. Default: all images')

    parser.add_argument('-c', '--command', help='command to execute (quoted). Default: `%(default)s`', default=DEFAULT_COMMAND)
    args = parser.parse_args()

    keystone = keystone_client.Client('2.0', username=args.os_username,
                                      password=args.os_password,
                                      tenant_name=args.os_tenant_name,
                                      auth_url=args.os_auth_url)

    glance_url = keystone.service_catalog.url_for(service_type='image')
    auth_token = keystone.auth_token
    glance = glance_client.Client('1', endpoint=glance_url, token=auth_token)
    images = []
    if not args.images:
        if args.public_images:
            images = [img for img in glance.images.list() if img.is_public]
        else:
            images = list(glance.images.list())
    else:
        images = [img for img in glance.images.list() if img.name in args.images or img.id in args.images]

    # Sort by image name
    images.sort(key=lambda x: x.name)
    nova = nova_client.Client('1.1', args.os_username,
                              args.os_password,
                              args.os_tenant_name,
                              args.os_auth_url)
    try:
        flavor = nova.flavors.find(name=args.flavor)
    except nova_ex.NotFound as ex:
        print("Flavor `%s` not found." % args.flavor)
        print("Available flavors:")
        print("* %s" % str.join('\n* ', [fl.name for fl in nova.flavors.list()]))
        sys.exit(1)

    try:
        keypair = nova.keypairs.find(name=args.key_name)
    except nova_ex.NotFound as ex:
        print("Keypair with name `%s` not found." % args.key_name)
        print("Available keypairs:")
        print("* %s" % str.join('\n* ', [kp.name for kp in nova.keypairs.list()]))
        sys.exit(1)


    failed_images = []
    for image in images:
        imgsize = float(image.size) / 2**30
        if imgsize > flavor.disk:
            print("Image '%s' cannot be started with flavor '%s'!" % (image.name, flavor.name))
            print("Image size: %.3fGB, flavor root disk: %d" % (imgsize, flavor.disk))
            failed_images.append((image, 'disk too small', -1))
            continue
        try:
            vm = nova.servers.create('Running "%s" on "%s"' % (args.command, image.name),
                                     image.id,
                                     flavor,
                                     key_name=args.key_name)
        except Exception as ex:
            print("Error starting vm with image %s (%s): %s" % (image.name, image.id, ex))
            continue
        print("VM %s started using image %s (%s)" % (vm.id, image.name, image.id))
        while vm.status == 'BUILD':
            vm = nova.servers.get(vm)
            time.sleep(WAIT)
        if vm.status != 'ACTIVE':
            print("VM %s didn't start correctly: in state %s. Deleting it!" % (vm.id, vm.status))
            failed_images.append((image, "VM didn't start", -1))
            vm.delete()
            continue
        if args.verbose:
            print("VM in status ACTIVE")

        # Assuming it's fine
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(IgnorePolicy())
        
        for iteration in range(10):
            if not vm.networks:
                # Network is not done yet?
                vm = nova.servers.get(vm)
                continue

            all_ips = reduce(operator.add, vm.networks.values())
            for ip in all_ips:
                if args.verbose:
                    print("Trying to connect to %s" % ip)
                try:
                    ssh.connect(ip, username=args.ssh_username,
                                allow_agent=True,
                                timeout=TIMEOUT)
                    break
                except (socket.error, socket.timeout) as ex:
                    if args.verbose:
                        print("Host unreachable")
                except paramiko.SSHException as ex:
                    if args.verbose:
                        print("Ignoring error %s" % ex)
            if ssh.get_transport() and ssh.get_transport().is_active():
                if args.verbose:
                    print("Connection open")
                try:
                    session = ssh.get_transport().open_session()
                    session.exec_command(args.command)
                    stdout = ""
                    stderr = ""
                    while not session.recv_ready():
                        if args.verbose: print("waiting for input")
                        time.sleep(1)
                    while session.recv_ready():
                        if args.verbose: print("reading 1024 bytes from stdout")
                        stdout += (session.recv(1024))

                    while session.recv_stderr_ready():
                        stderr += (session.recv_stderr(1024))
                    rc = session.recv_exit_status()
                    if rc:
                        failed_images.append((image, "Exit status %d != 0" % rc, rc))

                    if stdout:
                        print("----- stdout BEGIN ----")
                        sys.stdout.write(stdout)
                        sys.stdout.flush()
                        print("----- stdout END ----")
                    if stderr:
                        print("----- stderr BEGIN ----")
                        sys.stdout.write(stderr)
                        sys.stdout.flush()
                        print("----- stderr END ----")
                    print("Exit status: %d" % rc)
                    session.close()
                    ssh.close()
                    break
                except Exception as ex:
                    print("Error while running command: %s" % ex)
                    failed_images.append((image, "Error while running command", -1))
                    break
            else:
                if args.verbose:
                    print("No ssh connection so far")
        if args.verbose:
            print("Deleting vm %s" % vm.id)
        vm.delete()

    for img, expl, rc in failed_images:
        print("Image %s (%s) failed: %s" % (img.name, img.id, expl))
    sys.exit(len(failed_images))
